<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å‹•ç”»çµåˆãƒ„ãƒ¼ãƒ«</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <div class="container">
    <h1>å‹•ç”»çµåˆãƒ„ãƒ¼ãƒ«</h1>
    <p class="subtitle">è¤‡æ•°ã®å‹•ç”»ã‚’é †ç•ªã«çµåˆã—ã¾ã™ã€‚å‹•ç”»é–“ã«ãƒ†ãƒ­ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã‚’æŒ¿å…¥ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ã€‚</p>

    <div class="drop-zone" id="dropZone">
      <div class="drop-icon">ğŸ¬</div>
      <p class="drop-text">å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</p>
      <p class="drop-sub">ã¾ãŸã¯</p>
      <label class="btn-select" for="fileInput">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
      <input type="file" id="fileInput" accept="video/*" multiple hidden />
      <p class="supported">å¯¾å¿œå½¢å¼: MP4, MOV, AVI, MKV, WebM, FLV, M4V</p>
    </div>

    <ul class="item-list" id="itemList"></ul>

    <div class="actions">
      <button class="btn-merge" id="mergeBtn" disabled>çµåˆã™ã‚‹</button>
      <button class="btn-clear" id="clearBtn" hidden>ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="progress-area" id="progressArea" hidden>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <p class="progress-text" id="progressText">å‡¦ç†ä¸­...</p>
    </div>

    <div class="error-area" id="errorArea" hidden>
      <p class="error-msg" id="errorMsg"></p>
    </div>
  </div>

  <script>
    // items: Array of {id, type:'video', file:File} | {id, type:'text', text:string, duration:number}
    let items = [];
    let dragSrcIndex = null;

    const dropZone   = document.getElementById('dropZone');
    const fileInput  = document.getElementById('fileInput');
    const itemList   = document.getElementById('itemList');
    const mergeBtn   = document.getElementById('mergeBtn');
    const clearBtn   = document.getElementById('clearBtn');
    const progressArea  = document.getElementById('progressArea');
    const progressFill  = document.getElementById('progressFill');
    const progressText  = document.getElementById('progressText');
    const errorArea  = document.getElementById('errorArea');
    const errorMsg   = document.getElementById('errorMsg');

    function genId() { return Math.random().toString(36).slice(2); }

    // ---- Drop zone ----
    dropZone.addEventListener('dragover', e => {
      if ([...e.dataTransfer.types].includes('Files')) {
        e.preventDefault();
        dropZone.classList.add('dragover');
      }
    });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', e => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      addVideoFiles([...e.dataTransfer.files]);
    });
    fileInput.addEventListener('change', () => {
      addVideoFiles([...fileInput.files]);
      fileInput.value = '';
    });

    function addVideoFiles(files) {
      files
        .filter(f => f.type.startsWith('video/') || /\.(mp4|mov|avi|mkv|webm|flv|m4v)$/i.test(f.name))
        .forEach(f => items.push({ id: genId(), type: 'video', file: f }));
      render();
    }

    // ---- Render ----
    function render() {
      itemList.innerHTML = '';

      if (items.length > 0) {
        itemList.appendChild(makeInsertZone(0));
        items.forEach((item, i) => {
          itemList.appendChild(makeItemRow(item, i));
          itemList.appendChild(makeInsertZone(i + 1));
        });
      }

      const videoCount = items.filter(it => it.type === 'video').length;
      mergeBtn.disabled = videoCount === 0 || items.length < 2;
      clearBtn.hidden = items.length === 0;
      hideError();
    }

    // ---- Insert zone ----
    function makeInsertZone(insertIdx) {
      const div = document.createElement('div');
      div.className = 'insert-zone';
      div.dataset.insertIdx = insertIdx;

      const btn = document.createElement('button');
      btn.className = 'btn-insert';
      btn.textContent = '+ ãƒ†ãƒ­ãƒƒãƒ—ã‚’æŒ¿å…¥';
      btn.addEventListener('click', () => {
        items.splice(insertIdx, 0, { id: genId(), type: 'text', text: '', duration: 3 });
        render();
        // Focus the textarea of the newly inserted item
        const textareas = itemList.querySelectorAll('.text-input');
        const insertedTextarea = [...textareas][insertIdx];
        if (insertedTextarea) insertedTextarea.focus();
      });
      div.appendChild(btn);

      // Drop target for reorder
      div.addEventListener('dragover', e => { e.preventDefault(); div.classList.add('drag-over'); });
      div.addEventListener('dragleave', () => div.classList.remove('drag-over'));
      div.addEventListener('drop', e => {
        e.preventDefault();
        div.classList.remove('drag-over');
        if (dragSrcIndex === null) return;
        let targetIdx = parseInt(div.dataset.insertIdx);
        if (dragSrcIndex < targetIdx) targetIdx--;
        const [moved] = items.splice(dragSrcIndex, 1);
        items.splice(targetIdx, 0, moved);
        dragSrcIndex = null;
        render();
      });

      return div;
    }

    // ---- Item row ----
    function makeItemRow(item, i) {
      const li = document.createElement('li');
      li.className = `item-row ${item.type}-item`;
      li.dataset.index = i;

      // Drag handle
      const handle = document.createElement('span');
      handle.className = 'drag-handle';
      handle.textContent = 'â ¿';
      handle.title = 'ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä¸¦ã³æ›¿ãˆ';
      handle.addEventListener('mousedown', () => { li.draggable = true; });

      li.addEventListener('dragstart', e => {
        dragSrcIndex = i;
        li.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', String(i));
      });
      li.addEventListener('dragend', () => {
        li.classList.remove('dragging');
        li.draggable = false;
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        dragSrcIndex = null;
      });

      // Delete button
      const delBtn = document.createElement('button');
      delBtn.className = 'btn-delete';
      delBtn.textContent = 'âœ•';
      delBtn.title = 'å‰Šé™¤';
      delBtn.addEventListener('click', () => { items.splice(i, 1); render(); });

      // Icon
      const icon = document.createElement('span');
      icon.className = 'item-icon';

      li.appendChild(handle);
      li.appendChild(icon);

      if (item.type === 'video') {
        icon.textContent = 'ğŸ¬';
        const info = document.createElement('div');
        info.className = 'item-info';

        const name = document.createElement('span');
        name.className = 'item-name';
        name.textContent = item.file.name;

        const meta = document.createElement('span');
        meta.className = 'item-meta';
        meta.textContent = formatSize(item.file.size);

        info.appendChild(name);
        info.appendChild(meta);
        li.appendChild(info);

      } else {
        // Text card
        icon.textContent = 'ğŸ“';
        const content = document.createElement('div');
        content.className = 'text-card-content';

        const textarea = document.createElement('textarea');
        textarea.className = 'text-input';
        textarea.placeholder = 'ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ï¼ˆEnterã§æ”¹è¡Œï¼‰';
        textarea.rows = 2;
        textarea.value = item.text;
        textarea.addEventListener('input', () => { item.text = textarea.value; });
        textarea.addEventListener('mousedown', e => e.stopPropagation());

        const durationRow = document.createElement('div');
        durationRow.className = 'duration-row';

        const label = document.createElement('label');
        label.textContent = 'è¡¨ç¤ºæ™‚é–“:';

        const durInput = document.createElement('input');
        durInput.type = 'number';
        durInput.className = 'duration-input';
        durInput.value = item.duration;
        durInput.min = 0.5;
        durInput.max = 60;
        durInput.step = 0.5;
        durInput.addEventListener('change', () => {
          item.duration = Math.max(0.5, parseFloat(durInput.value) || 3);
        });
        durInput.addEventListener('mousedown', e => e.stopPropagation());

        const unit = document.createElement('span');
        unit.textContent = 'ç§’';

        durationRow.appendChild(label);
        durationRow.appendChild(durInput);
        durationRow.appendChild(unit);
        content.appendChild(textarea);
        content.appendChild(durationRow);
        li.appendChild(content);
      }

      li.appendChild(delBtn);
      return li;
    }

    function formatSize(bytes) {
      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
      if (bytes < 1024 * 1024 * 1024) return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
      return `${(bytes / 1024 / 1024 / 1024).toFixed(2)} GB`;
    }

    // ---- Clear ----
    clearBtn.addEventListener('click', () => { items = []; render(); });

    // ---- Merge ----
    mergeBtn.addEventListener('click', async () => {
      hideError();
      progressArea.hidden = false;
      mergeBtn.disabled = true;
      clearBtn.hidden = true;
      animateProgress();

      const formData = new FormData();
      const itemsDesc = [];

      items.forEach(item => {
        if (item.type === 'video') {
          formData.append('videos', item.file);
          itemsDesc.push({ type: 'video' });
        } else {
          itemsDesc.push({ type: 'text', text: item.text, duration: item.duration });
        }
      });
      formData.append('items', JSON.stringify(itemsDesc));

      try {
        const res = await fetch('/merge', { method: 'POST', body: formData });
        if (!res.ok) {
          const data = await res.json().catch(() => ({}));
          throw new Error(data.error || `ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ (${res.status})`);
        }
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'merged.mp4';
        a.click();
        URL.revokeObjectURL(url);

        progressFill.style.width = '100%';
        progressText.textContent = 'å®Œäº†ï¼ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå§‹ã¾ã‚Šã¾ã™ã€‚';
      } catch (err) {
        showError(err.message);
      } finally {
        setTimeout(() => {
          progressArea.hidden = true;
          progressFill.style.width = '0%';
          const videoCount = items.filter(it => it.type === 'video').length;
          mergeBtn.disabled = videoCount === 0 || items.length < 2;
          clearBtn.hidden = items.length === 0;
        }, 2000);
      }
    });

    function animateProgress() {
      progressFill.style.width = '0%';
      progressText.textContent = 'å‡¦ç†ä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„';
      let pct = 0;
      const iv = setInterval(() => {
        if (pct < 90) { pct += Math.random() * 3; progressFill.style.width = `${Math.min(pct, 90)}%`; }
        else clearInterval(iv);
      }, 400);
    }

    function showError(msg) { errorMsg.textContent = msg; errorArea.hidden = false; progressArea.hidden = true; }
    function hideError() { errorArea.hidden = true; }

    render();
  </script>
</body>
</html>
